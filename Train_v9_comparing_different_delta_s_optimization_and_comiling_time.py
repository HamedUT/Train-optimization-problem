# v3: Added Pm and Pn so the model decides for itself how much power to put
# v4: Added regenrative braking option in the objective function. Also calculated P of substations after model is solved.
# v5: Added P of substations as variables in the model. Also added braking_eff when writing to the txt file for further plot comparison. because when braking, all of the power is not going back to the grid
# v6: Added Voltage (After the solver and not in the model)
# v7: Adding the option to limit in terms of time instead of a constant value using the already created "data" dictionary. It reads data from a txt file and then set the limits on the train function only and not on the initializer.
# v8: Swapped the descritization of time by distance. Only one feature of topology is introduced here (gradient). generated by data_generator.py. Delta_s determines how detailed should the model run.
# v9: Added random gradients (per delta_s), random wind speed (for whole distance). all standardized for netherlands.

import pyomo.environ as pyomo
import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 14})
import numpy as np
import sys
import os
import random
import time


# Electrical Parameters
rho = 0.00003 # Ohms/m
V0 = 1500 # V

# Train Parameters
m = 150000 # kg (train weight, but should be variable later)
A = 2.88*4.30 # m^2 (Frontal area)
C = 0.002 # (Rolling resistance coefficient)
eta = 0.893564 # Efficiency of the train's propulsion system
C_d = 0.8 # (Drag coefficient)
braking_eff = 0.1 # Regenerative braking efficiency    
max_v = 44.444 # m/s = 160 km/h (VIRM)
max_acc = 0.768 # m/s2 (2.76 km/h/s) (VIRM)
max_p = 2157000 # W (max power)
min_p = max_p # W (min power)
aerodynamic_constant = 0.5 * 1.225 * C_d * A
rolling_resistance = C * m * 9.807

# Distance discretization
S = 10000 # (m) Length between Substation 1 and Substation 2
# delta_s = 50
total_time = 400 # (sec) From Substation 1 to Substation 2

# Time-dependent parameters
max_p_sub1 = 2157000 # W (max power for substation 1)
max_p_sub2 = 2157000 # W (max power for substation 2)

num_iterations = 1
total_time_spent = 0
  


for k in range(num_iterations):  
    for delta_s in [20, 25, 40, 50, 80, 100, 125, 200, 250, 400, 500, 625, 1000]:
        WindSpeed = 0#random.choice([random.uniform(-5, -2), random.uniform(2, 5)])  # m/s (Wind speed, excluding -2 to 2)

        gradients = [0.001]
        for i in range(1, S // delta_s):
            prev_gradient = 0.001
            new_gradient = prev_gradient
            gradients.append(new_gradient)
        start_time = time.time()
        data = {0: {'grade': gradients[0]}}
        num_steps = int(S / delta_s) + 1  # Number of distance steps
        for i in range(1, num_steps):
            distance = i * delta_s
            data[distance] = {'grade': gradients[min(i, len(gradients) - 1)],}

        def Initializer(S, delta_s, max_acc, data, m, C_d, A, C, eta, WindSpeed):
            D = data.keys()  # Distance steps
            model0 = pyomo.ConcreteModel()
            model0.v = pyomo.Var(D, domain=pyomo.NonNegativeReals, bounds=(0, max_v))  # Velocity (m/s)
            model0.P = pyomo.Var(D, domain=pyomo.Reals)  # Power consumption (kW)
            model0.t = pyomo.Var(D, domain=pyomo.NonNegativeReals)  # Time at each distance step
            model0.of = pyomo.Objective(expr=0.0, sense=pyomo.minimize)
            model0.cons = pyomo.ConstraintList()
            
            final_distance = list(D)[-1]
            # model0.cons.add(model0.s[final_time] == S)
            model0.t[0].fix(0)  # Initial time is 0
            model0.v[0].fix(0)  # Initial velocity is 0
            model0.v[final_distance].fix(0)  # Final velocity is 0
            model0.P[0].fix(0)


            for d in list(D)[1:]:
                prev_d = d - delta_s
                model0.cons.add(model0.t[d] == model0.t[prev_d] + 2 * delta_s / (model0.v[d] + model0.v[prev_d]))
                model0.cons.add((model0.v[d] - model0.v[prev_d]) / (2 * delta_s / (model0.v[d] + model0.v[prev_d])) <= max_acc)
                model0.cons.add(-(model0.v[d] - model0.v[prev_d]) / (2 * delta_s / (model0.v[d] + model0.v[prev_d])) <= max_acc)

                # Simpler version of Davies equation for power consumption
                model0.cons.add(model0.P[d] == 1 / eta * (
                    aerodynamic_constant * (model0.v[d] + WindSpeed)**2+
                    rolling_resistance +
                    m * 9.807 * data[d]['grade'] +  # Gradient at this distance
                    m * (model0.v[d] - model0.v[prev_d]) / (2 * delta_s / (model0.v[d] + model0.v[prev_d]))
                ) * model0.v[d])

            solver = pyomo.SolverFactory('ipopt')
            results = solver.solve(model0, tee=False)
            if results.solver.termination_condition == pyomo.TerminationCondition.optimal:
                v_opt = {d: model0.v[d].value for d in D}
                P_opt = {d: model0.P[d].value for d in D}
            else:
                print(f"Infeasible during Initialization - {results.solver.termination_condition}")
                sys.exit()
            return v_opt, P_opt

        def train(rho, S, delta_s, max_acc, max_p, data, m, C_d, A, C, eta, braking_eff, total_time, WindSpeed):
            v_opt, P_opt = Initializer(S, delta_s, max_acc, data, m, C_d, A, C, eta, WindSpeed)
            D = data.keys()
            
            model = pyomo.ConcreteModel()
            
            # Decision Variables
            model.v = pyomo.Var(D, domain=pyomo.NonNegativeReals, bounds=(0, max_v), initialize=lambda model0, d: v_opt[d]) # velocity (m/s)

            # State Variables
            model.Pm = pyomo.Var(D, domain=pyomo.NonNegativeReals, bounds=(0, max_p)) 
            model.Pn = pyomo.Var(D, domain=pyomo.NonNegativeReals, bounds=(0, min_p)) 
            model.P = pyomo.Var(D, domain=pyomo.Reals, initialize=lambda model0, d: P_opt[d])
            model.P_sub1 = pyomo.Var(D, domain=pyomo.Reals, bounds=(-max_p_sub1, max_p_sub1)) 
            model.P_sub2 = pyomo.Var(D, domain=pyomo.Reals, bounds=(-max_p_sub2, max_p_sub2))
            model.t = pyomo.Var(D, domain=pyomo.NonNegativeReals) # Distance 
            
            model.of = pyomo.Objective(expr=sum(model.Pm[d] - model.Pn[d] * braking_eff for d in D), sense=pyomo.minimize)
            
            # Constraints
            model.cons = pyomo.ConstraintList()
            final_distance = list(D)[-1]
                
            # Initial conditions
            model.v[0].fix(0)
            model.v[final_distance].fix(0)
            model.t[0].fix(0)
            model.t[final_distance].fix(total_time)
            # model.cons.add(model.s[final_distance] == S)
            model.P[0].fix(0)
            model.Pm[0].fix(0)
            model.Pn[0].fix(0)
            model.P_sub1[0].fix(0)
            model.P_sub2[0].fix(0)

            for d in list(D)[1:]:
                prev_d = d - delta_s
                model.cons.add(model.t[d] == model.t[prev_d] + 2 * delta_s / (model.v[d] + model.v[prev_d]))
                model.cons.add((model.v[d] - model.v[prev_d]) / (2 * delta_s / (model.v[d] + model.v[prev_d])) <= max_acc)
                model.cons.add(-(model.v[d] - model.v[prev_d]) / (2 * delta_s / (model.v[d] + model.v[prev_d])) <= max_acc)
                model.cons.add(model.P[d] == model.Pm[d] - model.Pn[d])
                model.cons.add(model.P_sub1[d] == model.P[d] * (S - d)/S)
                model.cons.add(model.P_sub2[d] == model.P[d] * d / S)
                
                # Davies equation for power consumption
                model.cons.add(model.P[d] == 1 / eta * (
                    aerodynamic_constant * (model.v[d] + WindSpeed)**2 +
                    rolling_resistance +
                    m * 9.807 * data[d]['grade'] +  # Gradient at this distance
                    m * (model.v[d] - model.v[prev_d]) / (2 * delta_s / (model.v[d] + model.v[prev_d]))
                ) * model.v[d]) 
                    
            solver = pyomo.SolverFactory('ipopt')
            results = solver.solve(model, tee=False)
            
            return model

        model = train(rho, S, delta_s, max_acc, max_p, data, m, C_d, A, C, eta, braking_eff, total_time, WindSpeed)
        end_time = time.time()
        def calculate_energy_consumption(model, data, delta_t):
            total_energy = 0  # Initialize total energy in joules
            for d in data.keys():
                total_energy += (model.P[d]() * delta_t) / 3.6e6 
            return total_energy

        total_time_spent += (end_time - start_time)
        avg_gradient = sum(gradients) / len(gradients)
        # print(f"Iteration {k + 1}/{num_iterations}...{end_time - start_time:.2f} seconds,  {calculate_energy_consumption(model, data, delta_s / max_v):.3f} kWh, Wind speed: {WindSpeed:0.2f} m/s, Average gradient: {avg_gradient:.5f}")
        print(f"Delta_s {delta_s}...{end_time - start_time:.2f} seconds,  {calculate_energy_consumption(model, data, delta_s / max_v):.3f} kWh, Wind speed: {WindSpeed:0.2f} m/s, Average gradient: {avg_gradient:.5f}")

average_time = total_time_spent / num_iterations
print(f"\nAverage time spent over {num_iterations} iterations: {average_time:.2f} seconds")